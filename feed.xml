<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://srtee.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://srtee.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-02-26T12:45:54+00:00</updated><id>https://srtee.github.io/feed.xml</id><title type="html">blank</title><subtitle>unconventional molecular dynamics researcher, open source scientific coder, sleep-deprived father </subtitle><entry><title type="html">Spack Time 2: Pigz flying off glyphs of doom</title><link href="https://srtee.github.io/blog/2022/spack-time-2-glyphs-of-doom/" rel="alternate" type="text/html" title="Spack Time 2: Pigz flying off glyphs of doom"/><published>2022-10-04T00:32:00+00:00</published><updated>2022-10-04T00:32:00+00:00</updated><id>https://srtee.github.io/blog/2022/spack-time-2-glyphs-of-doom</id><content type="html" xml:base="https://srtee.github.io/blog/2022/spack-time-2-glyphs-of-doom/"><![CDATA[<h2 id="gcc-aka-getting-code-compiled">GCC, aka Getting Code Compiled</h2> <p>Last I wrote, I’d typed in:</p> <p><code class="language-plaintext highlighter-rouge">spack install lammps</code></p> <p>An hour of computer time later, everything had Just Worked! Amazing!</p> <p>Excitedly, I fired up my new install with a <code class="language-plaintext highlighter-rouge">spack load lammps</code> and confirmed that I had … the 2021 stable version of LAMMPS. That was exciting in itself, because this confirmed that I could smoothly switch between my custom-compiled LAMMPS versions (based off the Sept 2022 patch) and what Spack had built. Time to build the latest version:</p> <p><code class="language-plaintext highlighter-rouge">spack install lammps@20220623</code></p> <p>and again, everything Just Worked!</p> <h2 id="time-to-get-my-oneapi-on">Time to get my OneAPI on</h2> <p>Following <a href="https://spack.readthedocs.io/en/latest/build_systems/inteloneapipackage.html">Spack’s instructions</a>, I installed the latest versions of Intel’s OneAPI and linked it up with Spack. That didn’t cause any trouble, which is notable because using Intel compilers on clusters has caused me grief in the past.</p> <p>So now it was time to get Spack going on my next big job:</p> <p><code class="language-plaintext highlighter-rouge">spack install lammps@20220915 %oneapi ^intel-oneapi-mkl ^intel-oneapi-mpi</code></p> <p>Let’s unspack<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> the “sigils” Spack uses:</p> <ol> <li><code class="language-plaintext highlighter-rouge">@</code> denotes a version string – LAMMPS uses patch dates, I’m not sure what Spack does with other packages.</li> <li><code class="language-plaintext highlighter-rouge">%</code> denotes the compiler used.</li> <li><code class="language-plaintext highlighter-rouge">^</code> denotes a specific dependency, because Spack can track abstract dependencies – for example, Spack knows that LAMMPS can use any MPI, so <code class="language-plaintext highlighter-rouge">^intel-oneapi-mpi</code> will tell Spack to use Intel MPI in that slot.</li> </ol> <p>And of course, everything compiled perfectly, and Shern coded happily ever after … <em>not</em>.</p> <h2 id="the-glyphs-of-doom">The glyphs of doom!</h2> <p>The first package which refused to compile was … <code class="language-plaintext highlighter-rouge">font-util</code>! This was an unpleasant surprise. If you’re familiar with LAMMPS you will be wondering, <em>why</em>? LAMMPS is after all a command-line-only molecular dynamics simulator, so what on earth is it doing looking for fonts? I haven’t looked at the dependency graphs but my guess is that some of the output modes probably feature fonts and therefore ask for <code class="language-plaintext highlighter-rouge">font-util</code> – or perhaps some other package in line has some odd dependency there.</p> <p>In any case, I was staring this right in the face:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     12934    /home/shernren/anaconda3/bin/fc-cache /home/shernren/spack/opt/spack/linux-ubuntu22.04-zen/oneapi-2022.1.0/font-util-1.3.2-yvqiyb6jnjnpo5ocw5nh4bfcplh2yqhq/share/fonts/X11/cyrillic
     12935    /home/shernren/spack/opt/spack/linux-ubuntu22.04-zen/oneapi-2022.1.0/font-util-1.3.2-yvqiyb6jnjnpo5ocw5nh4bfcplh2yqhq/share/fonts/X11/cyrillic: failed to write cache
  &gt;&gt; 12936    make[2]: *** [Makefile:755: install-data-hook] Error 1
     12937    make[2]: Leaving directory '/tmp/shernren/spack-stage/spack-stage-font-util-1.3.2-yvqiyb6jnjnpo5ocw5nh4bfcplh2yqhq/spack-src/font-cronyx-cyrillic/font-cronyx-cyrillic-1.0.3'
  &gt;&gt; 12938    make[1]: *** [Makefile:681: install-data-am] Error 2
     12939    make[1]: Leaving directory '/tmp/shernren/spack-stage/spack-stage-font-util-1.3.2-yvqiyb6jnjnpo5ocw5nh4bfcplh2yqhq/spack-src/font-cronyx-cyrillic/font-cronyx-cyrillic-1.0.3'
  &gt;&gt; 12940    make: *** [Makefile:632: install-am] Error 2
</code></pre></div></div> <p>Urgh! Argh! What on Earth! I duly googled “failed to write cache” and dived into a morass of old, odd bug reports. Eventually, it turned out that (1) this was <a href="https://gitlab.freedesktop.org/fontconfig/fontconfig/-/issues/107">an old bug in fontconfig</a>; (2) it was being triggered by <em>fontconfig from my Anaconda</em>.</p> <p>Of course Spack can’t solve my snake issues. But what I like about Spack is that, to me at least, it seems more transparent about the whole process. Instead of downloading wheels which magically go round and round and end up making my bus go forward, Spack is just (!) downloading source, compiling, and installing, and it happens to keep track of all its work with the hashes to show for it. I tacked on a few extra options: <code class="language-plaintext highlighter-rouge">-v --keep-prefix</code> to, respectively, give verbose output and keep all its temporary files around after a failed install. The install files eventually let me confirm that, yes, my Anaconda <code class="language-plaintext highlighter-rouge">fc-cache</code> was bugged while <code class="language-plaintext highlighter-rouge">/usr/bin/fc-cache</code> was updated to the latest version. After a quick and very dirty:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mv ~/anaconda/bin/fc-cache ~/anaconda/bin/fc-cache-old
ln -s /usr/bin/fc-cache ~/anaconda/bin/fc-cache
</code></pre></div></div> <p>I was on my way!</p> <h2 id="pigz-go-fly">Pigz go fly</h2> <p>Almost immediately another package decided to lie down and not compile, and it was <a href="https://zlib.net/pigz/"><code class="language-plaintext highlighter-rouge">pigz</code></a>. Another unpleasant surprise with an even more cryptic error message:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>==&gt; [2022-10-04-21:59:46.995345] 'make' '-j8'
gcc -O3 -Wall -Wextra -Wno-unknown-pragmas -Wcast-qual   -c -o pigz.o pigz.c
make: gcc: Permission denied
make: *** [&lt;builtin&gt;: pigz.o] Error 127
==&gt; Error: ProcessError: Command exited with status 2:
    'make' '-j8'

2 errors found in build log:
  &gt;&gt; 6    make: gcc: Permission denied
  &gt;&gt; 7    make: *** [&lt;builtin&gt;: pigz.o] Error 127
</code></pre></div></div> <p>Well, not very cryptic, in that I wasn’t able to use GCC while wanting to build everything with Intel’s ICPX! That again is a good sign that Spack really was going to compile everything with ICPX or die trying.</p> <p>But why was <code class="language-plaintext highlighter-rouge">pigz</code> asking for GCC? Again, Spack helpfully saved the source tar for me to peruse, and what should I find at the top of the Makefile but <code class="language-plaintext highlighter-rouge">CC=gcc</code>! Well, I don’t know how to get Spack to override the source it downloads<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>, but I knew I was never going to ask “but what if I compiled a parallel GZ compressor with Intel instead of GCC?”, so off we go changing the dependencies again:</p> <p><code class="language-plaintext highlighter-rouge">spack install lammps@20220915 %oneapi ^intel-oneapi-mkl ^intel-oneapi-mpi ^pigz%gcc</code></p> <p>And … it all worked! This last command has been running the whole time I’ve been typing this entry, and it’s built (glances at other terminal) an entire new Python, LLVM for AMD GPU (which, whoops, it’s just tripped over), and (hilariously) <em>a new fontconfig</em>, which would have been nice to have while font-util was tripping over itself!</p> <p>And instead of deciding to stop here (I can see it’s already decided that it can’t build Intel MPI without that mysterious AMD GPU LLVM, and therefore that it can’t build LAMMPS – sensible), it’s gone on now to build <em>Rust</em>!</p> <h2 id="if-only-this-were-a-conclusion">If only this were a conclusion</h2> <p>It seems that the journey goes on and on. But what I can tell is that Spack really, really does prioritize documenting a reproducible build. Of course it takes a lot of disk space to rebuild everything just to make sure it’s the same compiler throughout – but in the intended HPC use case, that totally makes sense.</p> <p>Even though I’m laughing (and crying) and some of the more ridiculous errors here, I don’t think they’re Spack’s fault. If I were building LAMMPS from ground up, especially with a list of different compilers and some of the more esoteric sub-packages, I’d be running headfirst into these speed bumps too. Spack is simply doing what I want it to do – and doing an admirable job keeping track of it all, and giving me the information I need to –</p> <p>dear heavens above, why is it building me <em>a brand new NumPy</em>???</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>I love my puns and I will not lie. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p>Spack does have a “develop mode” where it will build from my specified source directory instead of downloading from a Git repository. But I want to reserve that for developing LAMMPS, not pigz, and so I’ll wait until I have all my reference binaries compiled before tinkering with that. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="spack"/><category term="doco"/><summary type="html"><![CDATA[GCC, aka Getting Code Compiled]]></summary></entry><entry><title type="html">Spack Time 1: Getting started</title><link href="https://srtee.github.io/blog/2022/spack-time-1-getting-started/" rel="alternate" type="text/html" title="Spack Time 1: Getting started"/><published>2022-10-01T15:32:00+00:00</published><updated>2022-10-01T15:32:00+00:00</updated><id>https://srtee.github.io/blog/2022/spack-time-1-getting-started</id><content type="html" xml:base="https://srtee.github.io/blog/2022/spack-time-1-getting-started/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>I<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> have some time after sending a big paper off to my supervisor to read, and I’ve decided to overhaul my build environments. My work desktop has accumulated enough entropy that I can’t even power-cycle the <em>monitors</em> without having to hard-reset! So it’s time to back everything up and put on a fresh Linux install – which means I might as well do everything right.</p> <p><em>Right</em>, in this case, means documenting my build environment. To get all evangelistic, documentation is foundational to making science more <a href="https://www.go-fair.org/fair-principles/">FAIR</a>. Documentation is how a complete stranger in the scientific ecosystem can be confident that code I develop and deploy is safe to run on their computer, let alone that it will produce the right results. But guess who’s the biggest stranger in my life? It’s <em>me</em>! I can count on “me” of six months or six years from now to remember practically nothing first-hand, so being all documentative and FAIRy is good for myself as much as for the wider world.</p> <p>So here I am, documenting how I intend to set everything up correctly, and my first step is Spack.</p> <h2 id="spack-and-singularity">Spack (and Singularity)</h2> <blockquote> <p>Spack is a package manager for supercomputers, Linux, and macOS. It makes installing scientific software easy.</p> <p>from: <a href="https://spack.io/">Spack</a></p> </blockquote> <p>What? “Makes installing scientific software easy?” Sign me right up!</p> <p>I’ll start by trialling Spack on my home computer, which I’m not turning upside down and rattling at the same time as my work desktop, to see how it goes, and then see how the process goes on my work desktop.</p> <p>My specific use case is that I (with collaborators at the Hamburg University of Technology) develop the <a href="https://aip.scitation.org/doi/10.1063/5.0099239">ELECTRODE package</a>, as well as working on non-equilibrium methods in molecular dynamics with <a href="https://ctcms-uq.github.io/">CTCMS</a> at the University of Queensland, in the <a href="https://www.lammps.org/">LAMMPS</a> code. Besides developing generic code (and writing papers about it) I try to co-develop code with the INTEL package, which relies on Intel directives to go zoom zoom on Intel processors, and I am also co-developing code with the KOKKOS package to (soon) go zoom zoom on AMD GPUs on the brand new <a href="https://pawsey.org.au/systems/setonix/">Setonix</a> supercomputer.</p> <p>This means I need to test code against at least three compiler toolchains: Intel, AMD, and good old GCC (because I’m not a monster). In addition, I also want to link against a variety of FFT and linear algebra codes (such as MKL, openBLAS, or openBLIS). This kind of wacky combinatorial development is, supposedly, what Spack is good for. We’re about to find out!</p> <p>(I read lots of chatter about containerizing everything, and I know Singularity / Apptainer is a big deal for eventually deploying to HPC. But, from everything I’ve read, it sounds like Spack is great on boxes which I <em>own</em>, and eventually containers would be important for deploying either to HPC or cloud computes.)</p> <h2 id="installing-spack-and-lammps">Installing Spack and LAMMPS</h2> <p>So I installed Spack from GitHub using the <a href="https://spack-tutorial.readthedocs.io/en/latest/tutorial_basics.html">tutorial instructions</a>. Then, naively and straightforwardly, I typed in:</p> <p><code class="language-plaintext highlighter-rouge">spack install lammps</code></p> <p>and … it looks like it will take a while. This seems like a complete post now, so I’ll be back when it’s done!</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>You might not know who I am yet, and that’s okay! I really should write something about me before diving right into this blog, but Documenting Everything takes priority right now. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="spack"/><category term="doco"/><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>